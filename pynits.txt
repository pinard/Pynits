*pynits.txt*	Tidying up Python files

                        TIDYING PYTHON CODE WITHIN VIM

                               François Pinard
                           pinard@iro.umontreal.ca

Pynits is a tool which I find useful while editing Python source code
with Vim, for tidying up individual sources lines, and some auxiliary
tasks.  It is particularly helpful when formatting lines holding long
or complex expressions.  This tool requires a Python-enabled Vim.

1. Introduction                         |pynits-introduction|
2. Finding nits                         |pynits-finding-nits|
3. Reformatting lines                   |pynits-reformatting|
4. Other commands                       |pynits-other-commands|

The Pynits tool may be downloaded from:
    http://fp-etc.progiciels-bpi.ca/showfile.html?mode=archives
while installation directives may be found at:
    http://fp-etc.progiciels-bpi.ca/showfile.html?name=pynits/README
This file you are reading is also available on the Web as:
    http://fp-etc.progiciels-bpi.ca/showfile.html?name=pynits/pynits.txt

WARNING: This tool is in alpha state, its specifications may change.
Write to the author for corrections, suggestions or bug reports.

==============================================================================
1. Introduction					*pynits-introduction*

I once had to take over the maintenance of a set of big Python modules,
written by someone without much concern about source line length limits,
and also a bit lacking in the area of sound coding standards.  The
sources were hard to read on an usual terminal screen, hard to print
without stunts on a printer, hard to edit: in a word, hard to maintain.

When it comes to source coding standards, people develop religious
feelings.  My personal coding practices, which are somehow reflected in
this tool, are surely debatable and questionable, yet I dare to think
they are quite reasonable.  I use an eclectic choice of good ideas from
various sources: the Python mode as written for GNU Emacs, the standard
Python plugin for Vim, Guido's own style as he documented it, some
relevant parts of GNU and Gnits standards, good horse sense, but also,
my own programming experience, accumulated for a good while by now.

Source code lines are often carefully crafted by programmers, and a
reformatting tool may defeat local art work.  This is why I think
reformatting is best done from with a scalpel, like Vim may be, than
operated in bulk or in batch.  The programmer may choose to accept or
refuse, on a line basis, suggestions made by a tool like this one.

There are three sets of commands in this tool.  The first set is meant
to discover and report various formatting nits.  The programmer may then
ask the tool for correcting them, when a correction recipe is known.
The second set takes a whole Python source line, possibly continued, and
fully rebuilds a surface representation from its syntax tree.  The third
set contains a few random commands for simple tasks.

==============================================================================
2. Finding nits						*pynits-finding-nits*

All Python commands start with the |<LocalLeader>|, which is `\' if the
user did not change it.  All mapping equivalence tables, below, assume
that the local leader has not been set to some other value.  You should
change your reading of these maps if the leader happens to be different.

Mapping equivalences:
	\\	<Plug>Pynits_trouver_broutille
	\.	<Plug>Pynits_corriger_broutille

The exact nature formatting nit is uneasy to formalize, so I merely
escape the problem and define a nit as something I do not like! :-) This
tool knows about many nits, and when asked to find one with "\\", it
starts at the current line and forward, looking for all these nits in
parallel.  When "\\" is repeated after another, seeking resumes after
the found nit.  However, if the cursor moved or the line was modified
in the vicinity of the nit, seeking starts back at the beginning of the
current line, in case correcting a nit would have created another one.

When a nit is found, it is highlighted, and diagnosed at the last line
of the Vim frame.  However, merely because I do not know how to do
better, all textual contents similar to the nit are also highlighted.
But the nit really sits where the cursor is, best is to ignore the other
occurrences of the highlight.

Command "\." asks for the recently found nit to be corrected.  If the
tool knows how to do so, it corrects the nit and automatically proceed
to the next one.  Otherwise, it asks for a human to intervene, and does
not move the cursor.

==============================================================================
3. Reformatting lines					*pynits-reformatting*

Given the cursor is on a line of Python code, the following commands
all reformat a Python line, but may yield different results whenever
continuation lines are needed.  If the cursor is on a comment line, all
the comment block encompassing the current line is reformatted.  If the
cursor is on a white line, extraneous white lines are deleted.  Let's
concentrate on Python code first.  See near the end of this section for
ints about how comments are processed.

Mapping equivalences:
	\c	<Plug>Pynits_disposer_en_colonne
	\l	<Plug>Pynits_disposer_en_ligne
	\m	<Plug>Pynits_disposer_en_mixte
	\q	<Plug>Pynits_disposer_en_mixte_remplie
	\r	<Plug>Pynits_disposer_en_colonne_remplie

When any of the above command is given, the tool first tries to find
the Python line holding the cursor.  A Python line, here, means a set
of physical lines in the buffer representing a single logical line, but
possibly continued (either through an escaped-newline or an unbalanced
bracket of any kind).  The Python line may start as far as a dozen
physical lines before the cursor, and the Python line may hold as much
as two dozen lines.  Beware that a physical line may look, all in
itself, like a valid Python statement, while it is really a continuation
line.  This tool may be fooled by such cases, so it may happen that you
ought to explicitly reposition the cursor on the first physical line
of the Python line first.  As the cursor is left on the physical line
following the Python line after the operation, this gives you a good
clue about what the tool found out to be a Python line.

Command "\l" reformats the Python line into a single physical line with
no limit for the line length, and is meant to be useful as a first step
when the programmer wants to fully hand-craft the formatting.  All other
commands in this category try hard to fit the Python line into one or
more physical lines of no more than 80 columns each.

Command "\c" reformats the Python line so to vertically align
continuation lines into a column, the position of which is selected to
better stress the syntactic structure of a statement or expression.
Command "\m" will rather align continuation lines by indenting the
margin by a fixed amount, this is a bit less legible, yet still
acceptable as this may save a few continuation lines.  However, "\m"
will always revert to "\c", and recursively, if both yield the same
number of continuation lines.

Command "\r" is the same as "\c" with refilling, while command "\q" is
the same as "\m" with refilling.  Refilling is an operation by which
continuation lines are combined after having been produced, only given
this combining is natural and meaningful.  Here as well, refilling
may represent some loss in legibility, but so might be using too much
vertical space, so refilling may often be a worth compromise.

How to remember all these letters? "\q" has been chosen after "gq",
which is the standard Vim command for reformatting a paragraph.  Our
suggestion is that you use "\q", and only attempt one of the others if
you are not satisfied by what you get.  And always keep in mind this
wonderful Vim undo facility!  The other letters are chosen to stress a
particular aspect of the reformatting, and they all to less work than
"\q": "\c" favors columns, "\m" favors margins, "\r" favors refilling.

Most of these commands accomplish a lot of work, and some heuristics
keep a bound on the combinatorial complexity of the reformatting task.
To help me at this, and maybe for your entertainment as well, the above
commands echo a few statistics: the total number of formatting attempts,
the number of times successful attempts were in competition and had
to undergo selection through quality comparison, and how many times a
formatting sequence trapped itself into some dead-end.

Mapping equivalences:
	\od	<Plug>Pynits_choisir_mise_au_point
	\om	<Plug>Pynits_montrer_syntaxe
	\or	<Plug>Pynits_choisir_remplisseur

These three commands, all starting with "\o", are meant for the maintainer of
this tool for debugging, yet the third may have a wider usage, see below.

Command "\od" toggles the debugging level between a few states, in
a round-robin fashion.  By default, and initially, debugging is not
active.  A second level has the effect of mangling the result, each
alphanumeric character being replaced by a letter indicating the
strategy which was active when this character was being produced.  A
third level details the arbitration process when successful formattings
get into competition.  The fourth and last level gives an extremely
verbose trace, and is only meant for resisting bugs!

Command "\om" does not do any formatting, but merely dumps the syntactic
tree of the selected Python line.

Command "\or" toggles between a few refilling algorithms for comments,
in a round-robin fashion.  By default, and initially, comment refilling
is effected through the GNU `fmt' program, which should be already
installed in the system: it seems to me that wherever it fits, this is
the tool producing the nicest output.  The second algorithm uses the
`par' program, which despite a bit less nice than `fmt', is more clever
in some circumstances of complex quoting or boxing.  The third algorithm
uses the Vim built-in paragraph reformatter, which seems a bit less
interesting, but it may only be that I did not much study it yet.  The
fourth and last algorithm is the `textwrap' module from the Python 2.3
distribution, in practice so far, it does not seem fully up to the task.

This tool does not like intra-line comments.  All comments are extracted
out of a Python line, and put either before it if the line does not end
with a colon, or after it whenever the Python line ends with a colon.

==============================================================================
4. Other commands					*pynits-other-commands*

Mapping equivalences:
	\"	<Plug>Pynits_forcer_guillemets
	\'	<Plug>Pynits_forcer_apostrophes
	\(	<Plug>Pynits_ajouter_parentheses
	\)	<Plug>Pynits_eliminer_parentheses

Command `\"' seeks for the next string delimited by single quotes after
the cursor on the current line, and changes the delimiters to double
quotes.  Command `\'' similarly changes a double-quoted string into a
single-quoted string.  Both these commands have an approximative effect,
they do not currently try to be right in every circumstance.

Command `\(' adds an opening round parenthesis under the cursor, and a
closing round parenthesis at the end of the physical line.  If the line
ends with a colon, the closing parenthesis is added before the colon
instead of after it.  Command `\)' only works in the cursor sits over
an opening or closing bracket of any kind, it deletes both the bracket
under the cursor and the matching bracket, would it be on another line.

vim:tw=78:ts=8:ft=help:norl:
